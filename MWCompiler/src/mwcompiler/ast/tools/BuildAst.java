package mwcompiler.ast.tools;

import mwcompiler.ast.nodes.*;
import mwcompiler.symbols.*;
import mwcompiler.utility.Colors;
import mwcompiler.utility.CompileError;
import mx_gram.tools.*;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.tree.*;

import java.util.ArrayList;
import java.util.List;

import static mwcompiler.symbols.NonArrayTypeSymbol.*;

/**
 * BuildAst.java
 * Class for building the AST, by extending from the MxBase Visitor generated by antlr.v4
 *
 * @author Michael Wu
 * @since 2018-04-06
 */
public class BuildAst extends MxBaseVisitor<Node> {
    private String stage = "Building Ast";
    private TokenStream token;

    public BuildAst(TokenStream token){
        this.token = token;
    }

    private void buildClassSymbol(MxParser.ProgramContext ctx) {
        for (ParseTree child : ctx.declarator()) {
            if (child.getChild(0) instanceof MxParser.ClassDeclFieldContext) {
                NonArrayTypeSymbol.builder(
                        ((MxParser.ClassDeclFieldContext) child.getChild(0)).classField().Identifier().getText());
            }
        }
    }

    private String getFirstLine(ParserRuleContext ctx) {
        return token.getText(ctx).split("\r?\n")[0];
    }

    @Override
    public Node visitProgram(MxParser.ProgramContext ctx) {
        List<Node> declarators = new ArrayList<>();
        Location programPos = new Location(1, 1);
        buildClassSymbol(ctx);
        for (ParseTree child : ctx.declarator()) {
            Node childNode = visit(child);
            if (childNode instanceof DeclaratorNode) {
                declarators.add(childNode);
                if (childNode instanceof VariableDeclNode) {
                    VariableDeclNode variableDeclNode = (VariableDeclNode) childNode;
                    TypeSymbol search = TypeSymbol.searchSymbol(variableDeclNode.getVarSymbol().getName());
                    if (search != null) {
                        throw new CompileError(stage, "Can not use the same name <" + Colors.GREEN
                                + variableDeclNode.getVarSymbol().getName() + "> for class and " +
                                "variable in same scope", variableDeclNode.getStartLocation(), token.getText(ctx));
                    }
                }
            } else
                throw new CompileError(
                        stage, "Get unexpected statement when visiting the global scope", programPos, childNode.getText());
        }
        BlockNode block = new BlockNode(declarators, programPos);
        return new ProgramNode(block, new Location(ctx));
    }

    // Variable declaration
    @Override
    public Node visitVariableDeclField(MxParser.VariableDeclFieldContext ctx) {
        VariableDeclNode node = (VariableDeclNode) visit(ctx.variableField());
        TypeNode typeNode = (TypeNode) visit(ctx.type());
        node.setType(typeNode.getTypeSymbol(), new Location(ctx.type()));
        node.setText(token.getText(ctx));
        return node;
    }

    @Override
    public Node visitVariableField(MxParser.VariableFieldContext ctx) {
        String var = ctx.Identifier().getText();
        Location varPos = new Location(ctx.Identifier());
        ExprNode init = null;
        Location initPos = null;
        if (ctx.variableInitializer() != null) {
            init = (ExprNode) this.visit(ctx.variableInitializer());
            initPos = new Location(ctx.ASSIGN());
        }
        return new VariableDeclNode(null, var, init, null, varPos, initPos);
    }

    @Override
    public Node visitVariableInitializer(MxParser.VariableInitializerContext ctx) {
        return this.visit(ctx.expr());
    }

    // Function declaration
    private FunctionDeclNode getFunctionField(TerminalNode identifier,
                                              MxParser.ParamExprFieldContext paramExprFieldContext, MxParser.FunctionBodyContext functionBodyContext) {
        Location identifierLocation = new Location(identifier);
        Location paramLocation = new Location(paramExprFieldContext);
        Location functionBodyLocation = new Location(functionBodyContext);
        List<VariableDeclNode> params = new ArrayList<>();
        for (MxParser.ParamExprContext param : paramExprFieldContext.paramExpr()) {
            params.add((VariableDeclNode) visit(param));
        }
        BlockNode body = (BlockNode) visit(functionBodyContext);
        String name = identifier.getText();
        // Creator Function
        TypeSymbol search = TypeSymbol.searchSymbol(name);
        if (search instanceof NonArrayTypeSymbol) {
            return new FunctionDeclNode(search, InstanceSymbol.constructorSymbol, params, body, null,
                    identifierLocation, paramLocation, functionBodyLocation);
        }

        InstanceSymbol instanceSymbol;
        try {
            instanceSymbol = InstanceSymbol.builder(name);
        } catch (RuntimeException e) {
            throw new CompileError(
                    stage, e.getMessage(), new Location(identifier), name);
        }

        return new FunctionDeclNode(null, instanceSymbol, params, body, null, new Location(identifier),
                new Location(paramExprFieldContext), new Location(functionBodyContext));
    }


    @Override
    public Node visitTypeFunction_(MxParser.TypeFunction_Context ctx) {
        TypeNode returnTypeNode = (TypeNode) visit(ctx.type());
        FunctionDeclNode node = (FunctionDeclNode) visit(ctx.functionField());
        node.setReturnType(returnTypeNode.getTypeSymbol(), new Location(ctx.type()));
        node.setText(getFirstLine(ctx));
        return node;
    }

    @Override
    public Node visitVoidFunction_(MxParser.VoidFunction_Context ctx) {
        TypeSymbol returnType = NonArrayTypeSymbol.builder("void");
        FunctionDeclNode node = (FunctionDeclNode) visit(ctx.functionField());
        node.setReturnType(returnType, new Location(ctx.VOID()));
        node.setText(getFirstLine(ctx));
        return node;
    }

    @Override
    public Node visitClassConstructField(MxParser.ClassConstructFieldContext ctx) {
        FunctionDeclNode node = getFunctionField(ctx.Identifier(), ctx.paramExprField(), ctx.functionBody());
        node.setText(getFirstLine(ctx));
        return node;
    }

    @Override
    public Node visitFunctionField(MxParser.FunctionFieldContext ctx) {
        return getFunctionField(ctx.Identifier(), ctx.paramExprField(), ctx.functionBody());
    }

    @Override
    public Node visitParamExpr(MxParser.ParamExprContext ctx) {
        TypeNode typeNode = (TypeNode) visit(ctx.type());
        String name = ctx.Identifier().getText();
        return new VariableDeclNode(typeNode.getTypeSymbol(), name, null, new Location(ctx.type()),
                new Location(ctx.Identifier()), null);
    }

    @Override
    public Node visitFunctionBody(MxParser.FunctionBodyContext ctx) {
        return visit(ctx.block());
    }

    // Class declaration

    @Override
    public Node visitClassDeclField(MxParser.ClassDeclFieldContext ctx) {
        ClassDeclNode node = (ClassDeclNode) visit(ctx.classField());
        node.setText(getFirstLine(ctx));
        return node;
    }

    @Override
    public Node visitClassField(MxParser.ClassFieldContext ctx) {
        String declClass = ctx.Identifier().getText();
        List<Node> body = new ArrayList<>();
        Location declClassPos = new Location(ctx.Identifier());
        Location bodyPos = new Location(ctx.LBRACE());
        for (MxParser.ClassBodyContext declarator : ctx.classBody()) {
            Node statement = visit(declarator);
            if (statement instanceof VariableDeclNode) {
                body.add(visit(declarator));

            } else if (statement instanceof FunctionDeclNode) {
                FunctionDeclNode functionDeclNode = (FunctionDeclNode) statement;
                body.add(visit(declarator));
                if (functionDeclNode.getInstanceSymbol() == InstanceSymbol.constructorSymbol
                        && !(functionDeclNode.getFunctionTypeSymbol().getReturnType().getName().equals(declClass))) {
                    throw new CompileError(stage, "Creator function must have the same name as the class"
                            , new Location(declarator), functionDeclNode.getText());
                }
            } else {
                throw new CompileError(stage, "Unexpected statement found in Class declaration"
                        , declClassPos, statement.getText());
            }
        }
        BlockNode block = new BlockNode(body, bodyPos);
        ClassDeclNode classDeclNode;
        try {
            classDeclNode = new ClassDeclNode(declClass, block, declClassPos);
        } catch (CompileError e) {
            throw new CompileError(stage, e.getMessage(), declClassPos, getFirstLine(ctx));
        }
        return classDeclNode;
    }

    // Block
    @Override
    public Node visitBlock(MxParser.BlockContext ctx) {
        List<Node> statements = new ArrayList<>();
        for (MxParser.StatementContext state : ctx.statement()) {
            statements.add(visit(state));
        }
        return new BlockNode(statements, new Location(ctx));
    }

    // NonArrayTypeSymbol
    @Override
    public Node visitType(MxParser.TypeContext ctx) {
        String type = ctx.nonArrayType().getText();

        return new TypeNode(type, ctx.LBRACK().size(), new Location(ctx));
    }

    // Expressions
    @Override
    public Node visitExprField(MxParser.ExprFieldContext ctx) {
        if (ctx.expr() != null) {
            ExprNode node = (ExprNode) visit(ctx.expr());
            node.setText(token.getText(ctx));
            return node;
        }
        return new EmptyExprNode(new Location(ctx));
    }

    @Override
    public Node visitLiteral(MxParser.LiteralContext ctx) {
        String val = ctx.getText();
        LiteralExprNode node;
        Location literalPos = new Location(ctx.literalType);
        switch (ctx.literalType.getType()) {
            case MxParser.BoolLiteral:
                node = new BoolLiteralNode(val, literalPos);
                break;
            case MxParser.IntLiteral:
                node = new IntLiteralNode(val, literalPos);
                break;
            case MxParser.StringLiteral:
                node = new StringLiteralNode(val, literalPos);
                break;
            case MxParser.NULL:
                node = new NullLiteralNode(literalPos);
                break;
            default:
                throw new CompileError(stage, "Get unexpected literal typename when visiting literal"
                        , literalPos, token.getText(ctx));
        }
        return node;
    }

    @Override
    public Node visitIdentifier_(MxParser.Identifier_Context ctx) {
        return new IdentifierExprNode(ctx.getText(), new Location(ctx), token.getText(ctx));
    }

    // Binary Expression
    @Override
    public Node visitBinaryExpr_(MxParser.BinaryExpr_Context ctx) {
        ExprNode.OPs op;
        Location opPos = new Location(ctx.op);
        switch (ctx.op.getType()) {
            case MxParser.MUL: op = ExprNode.OPs.MUL;
                break;
            case MxParser.DIV: op = ExprNode.OPs.DIV;
                break;
            case MxParser.MOD: op = ExprNode.OPs.MOD;
                break;
            case MxParser.ADD: op = ExprNode.OPs.ADD;
                break;
            case MxParser.SUB: op = ExprNode.OPs.SUB;
                break;
            case MxParser.LSFT: op = ExprNode.OPs.LSFT;
                break;
            case MxParser.RSFT: op = ExprNode.OPs.RSFT;
                break;
            case MxParser.LT: op = ExprNode.OPs.LT;
                break;
            case MxParser.GT: op = ExprNode.OPs.GT;
                break;
            case MxParser.LTE: op = ExprNode.OPs.LTE;
                break;
            case MxParser.GTE: op = ExprNode.OPs.GTE;
                break;
            case MxParser.EQ: op = ExprNode.OPs.EQ;
                break;
            case MxParser.NEQ: op = ExprNode.OPs.NEQ;
                break;
            case MxParser.BITAND: op = ExprNode.OPs.BITAND;
                break;
            case MxParser.BITXOR: op = ExprNode.OPs.BITXOR;
                break;
            case MxParser.BITOR: op = ExprNode.OPs.BITOR;
                break;
            case MxParser.AND: op = ExprNode.OPs.AND;
                break;
            case MxParser.OR: op = ExprNode.OPs.OR;
                break;
            case MxParser.ASSIGN: op = ExprNode.OPs.ASSIGN;
                break;
            default:
                throw new CompileError(
                        stage, "Get unexpected operator at BinaryExpression ", opPos, token.getText(ctx));
        }
        return new BinaryExprNode((ExprNode) this.visit(ctx.expr(0)), op, (ExprNode) this.visit(ctx.expr(1)), opPos, token.getText(ctx));
    }

    // Unary Expression
    @Override
    public Node visitSuffixIncDec_(MxParser.SuffixIncDec_Context ctx) {
        ExprNode node = (ExprNode) visit(ctx.expr());
        ExprNode.OPs op;
        Location opPos = new Location(ctx.op);

        switch (ctx.op.getType()) {
            case MxParser.INC: op = ExprNode.OPs.INC_SUFF;
                break;
            case MxParser.DEC: op = ExprNode.OPs.DEC_SUFF;
                break;
            default:
                throw new CompileError(
                        stage, "Get unexpected op at SuffixIncDec", opPos, token.getText(ctx));

        }
        return new UnaryExprNode(op, node, new Location(ctx.op), token.getText(ctx));
    }

    @Override
    public Node visitUnaryExpr_(MxParser.UnaryExpr_Context ctx) {
        ExprNode.OPs op;
        Location opPos = new Location(ctx.op);
        switch (ctx.op.getType()) {
            case MxParser.INC: op = ExprNode.OPs.INC;
                break;
            case MxParser.DEC: op = ExprNode.OPs.DEC;
                break;
            case MxParser.ADD: op = ExprNode.OPs.ADD;
                break;
            case MxParser.SUB: op = ExprNode.OPs.SUB;
                break;
            case MxParser.NOT: op = ExprNode.OPs.NOT;
                break;
            case MxParser.BITNOT: op = ExprNode.OPs.BITNOT;
                break;
            default:
                throw new CompileError(stage, "Get unexpected operator" + ctx.op.getText()
                        + " in unary expression", opPos, token.getText(ctx));
        }
        return new UnaryExprNode(op, (ExprNode) visit(ctx.expr()), opPos, token.getText(ctx));
    }

    // New
    @Override
    public Node visitNewCreator_(MxParser.NewCreator_Context ctx) {
        return visit(ctx.creator());
    }

    @Override
    public Node visitCreator(MxParser.CreatorContext ctx) {
        String createType = ctx.createdName().getText();
        Integer dim = 0;
        List<ExprNode> dimArgs = new ArrayList<>();
        if (ctx.arrayCreatorRest() != null) {
            List<MxParser.CreatorInnerContext> creatorInnerContext = ctx.arrayCreatorRest().creatorInner();
            dim = creatorInnerContext.size();
            for (Integer index = 0; index < dim; ++index) {
                MxParser.ExprContext exprContext = creatorInnerContext.get(index).expr();
                if (exprContext != null) {
                    if (index != dimArgs.size()) {
                        throw new CompileError(
                                stage, "Syntax Expect a ']'," + " but a illegal expression start",
                                new Location(creatorInnerContext.get(index)), token.getText(ctx));
                    }
                    dimArgs.add((ExprNode) visit(exprContext));
                }
            }
        }
        return new NewExprNode(createType, dim, dimArgs, new Location(ctx.createdName()));
    }

    // Function Call
    @Override
    public Node visitFunctionCall_(MxParser.FunctionCall_Context ctx) {
        List<ExprNode> args = new ArrayList<>();
        if (ctx.arguments().exprList() != null) {
            for (MxParser.ExprContext expr : ctx.arguments().exprList().expr()) {
                args.add((ExprNode) visit(expr));
            }
        }
        // For constructor
        if (ctx.expr() instanceof MxParser.Identifier_Context) {
            TypeSymbol symbol = TypeSymbol.searchSymbol(((MxParser.Identifier_Context) ctx.expr()).Identifier().getText());
            if (symbol instanceof NonArrayTypeSymbol) {
                return new ConstructorCallNode((NonArrayTypeSymbol) symbol, args, new Location(ctx.arguments()));
            }
        }

        // For normal function
        ExprNode caller = (ExprNode) visit(ctx.expr());
        return new FunctionCallNode(caller, args, new Location(ctx.arguments()), token.getText(ctx));
    }

    // Member Function call
    @Override
    public Node visitDotMember_(MxParser.DotMember_Context ctx) {
        ExprNode container = (ExprNode) visit(ctx.expr());
        IdentifierExprNode member = new IdentifierExprNode(ctx.Identifier().getText(), new Location(ctx.Identifier()), token.getText(ctx));
        return new DotMemberNode(container, member, new Location(ctx.DOT()));
    }

    @Override
    public Node visitBrackMember_(MxParser.BrackMember_Context ctx) {
        ExprNode mom = (ExprNode) visit(ctx.mom);
        ExprNode subscript = (ExprNode) visit(ctx.subscript);
        return new BrackMemberNode(mom, subscript, new Location(ctx.LBRACK()));
    }

    @Override
    public Node visitThis_(MxParser.This_Context ctx) {
        return new IdentifierExprNode("this", new Location(ctx.THIS()), token.getText(ctx));
    }

    @Override
    public Node visitParenExpr_(MxParser.ParenExpr_Context ctx) {
        return visit(ctx.expr());
    }

    // If statement
    @Override
    public Node visitConditionField(MxParser.ConditionFieldContext ctx) {
        ExprNode condition = (ExprNode) visit(ctx.cond);
        BlockNode body = (BlockNode) visit(ctx.body());
        IfNode ifNode = new IfNode(condition, body, new Location(ctx.IF()), getFirstLine(ctx));
        IfNode prevCond = ifNode;
        if (ctx.elseifConditionField().size() != 0) {
            for (MxParser.ElseifConditionFieldContext field : ctx.elseifConditionField()) {
                IfNode nextCond = (IfNode) visit(field);
                prevCond.setElseCondition(nextCond);
                prevCond = nextCond;
            }
        }
        if (ctx.elseConditionField() != null) {
            prevCond.setElseCondition((IfNode) visit(ctx.elseConditionField()));
        }
        return ifNode;
    }

    @Override
    public Node visitElseifConditionField(MxParser.ElseifConditionFieldContext ctx) {
        return new IfNode((ExprNode) visit(ctx.cond), (BlockNode) visit(ctx.body()), new Location(ctx.ELSE()), getFirstLine(ctx));
    }

    @Override
    public Node visitElseConditionField(MxParser.ElseConditionFieldContext ctx) {
        return new IfNode(null, (BlockNode) visit(ctx.body()), new Location(ctx.ELSE()), getFirstLine(ctx));
    }

    // Loop statement
    @Override
    public Node visitForField(MxParser.ForFieldContext ctx) {
        Node vardecl = null;
        ExprNode condition = null;
        ExprNode step = null;
        BlockNode body = (BlockNode) visit(ctx.body());
        Location vardeclPos = null;
        Location conditionPos = null;
        Location stepPos = null;
        if (ctx.type() != null) {
            vardeclPos = new Location(ctx.type());
            if (ctx.variableField() == null) {
                throw new CompileError(stage, "Syntax Error. Condition field in for should contain "
                        + "complete variable declaration or initialization", new Location(ctx.type()), null);
            }
            VariableDeclNode node = (VariableDeclNode) visit(ctx.variableField());
            TypeNode typeNode = (TypeNode) visit(ctx.type());
            node.setType(typeNode.getTypeSymbol(), vardeclPos);
            vardecl = node;
        } else {
            if (ctx.variableField() != null) {
                VariableDeclNode variableDeclNode = (VariableDeclNode) visit(ctx.variableField());
                vardecl = new BinaryExprNode(
                        new IdentifierExprNode(variableDeclNode.getVarSymbol(), new Location(ctx.variableField())),
                        ExprNode.OPs.ASSIGN, variableDeclNode.getInit(), new Location(ctx.variableField()), token.getText(ctx));
            }
        }

        if (ctx.cond != null) {
            condition = (ExprNode) visit(ctx.cond);
            conditionPos = new Location(ctx.cond);
        }
        if (ctx.step != null) {
            step = (ExprNode) visit(ctx.step);
            stepPos = new Location(ctx.step);
        }
        return new LoopNode(vardecl, condition, step, body, vardeclPos, conditionPos, stepPos, getFirstLine(ctx));
    }

    @Override
    public Node visitWhileField(MxParser.WhileFieldContext ctx) {
        ExprNode condition = null;
        Location condPos = null;
        BlockNode body = (BlockNode) visit(ctx.body());
        if (ctx.cond != null) {
            condition = (ExprNode) visit(ctx.cond);
            condPos = new Location(ctx.cond);
        }
        return new LoopNode(null, condition, null, body, null, condPos, null, getFirstLine(ctx));
    }

    @Override
    public Node visitBody(MxParser.BodyContext ctx) {
        Node node = visit(ctx.statement());
        if (node instanceof BlockNode) {
            return node;
        } else {
            List<Node> statements = new ArrayList<>();
            statements.add(node);
            return new BlockNode(statements, new Location(ctx));
        }
    }

    @Override
    public Node visitJumpField(MxParser.JumpFieldContext ctx) {
        ExprNode node = (ExprNode) visit(ctx.jump());
        node.setText(token.getText(ctx));
        return node;
    }

    @Override
    public Node visitReturnJump_(MxParser.ReturnJump_Context ctx) {
        ExprNode node = null;
        if (ctx.expr() != null)
            node = (ExprNode) visit(ctx.expr());
        return new ReturnNode(node, new Location(ctx));
    }

    @Override
    public Node visitBreakJump_(MxParser.BreakJump_Context ctx) {
        return new BreakNode(new Location(ctx));
    }

    @Override
    public Node visitContinueJump_(MxParser.ContinueJump_Context ctx) {
        return new ContinueNode(new Location(ctx));
    }

    public void setToken(TokenStream token) {
        this.token = token;
    }
}
