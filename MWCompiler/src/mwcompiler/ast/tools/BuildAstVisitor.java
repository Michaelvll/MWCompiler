package mwcompiler.ast.tools;

import mwcompiler.ast.nodes.*;
import mx_gram.tools.*;

import org.antlr.v4.runtime.tree.*;

import java.util.ArrayList;
import java.util.List;

/**
 * BuildAstVisitor.java
 * Class for building the AST, by extending from the MxBase Visitor generated by antlr.v4
 *
 * @author Michael Wu
 * @since 2018-04-06
 */
public class BuildAstVisitor extends MxBaseVisitor<Node> {

    @Override
    public Node visitProgram(MxParser.ProgramContext ctx) {
        List<DeclaratorNode> declarators = new ArrayList<>();
        for (ParseTree child : ctx.declarator()) {
            Node childNode = visit(child);
            if (childNode instanceof DeclaratorNode)
                declarators.add((DeclaratorNode) childNode);
            else
                throw new RuntimeException("Type Mismatch when visiting program");
        }
        return new ProgramNode(declarators);
    }

    // Variable declaration
    @Override
    public Node visitVariableDeclField(MxParser.VariableDeclFieldContext ctx) {
        VariableDeclNode node = (VariableDeclNode) visit(ctx.variableField());
        node.setType((TypeNode) visit(ctx.type()), new Location(ctx.type()));
        return node;
    }


    @Override
    public Node visitVariableField(MxParser.VariableFieldContext ctx) {
        String var = ctx.Identifier().getText();
        Location varPos = new Location(ctx.Identifier());
        ExprNode init = null;
        Location initPos = null;
        if (ctx.variableInitializer() != null) {
            init = (ExprNode) this.visit(ctx.variableInitializer());
            initPos = new Location(ctx.variableInitializer());
        }
        return new VariableDeclNode(null, var, init, null, varPos, initPos);
    }

    @Override
    public Node visitVariableInitializer(MxParser.VariableInitializerContext ctx) {
        return this.visit(ctx.expr());
    }

    // Function declaration
    @Override
    public Node visitTypeFunction_(MxParser.TypeFunction_Context ctx) {
        TypeNode returnType = (TypeNode) visit(ctx.type());
        FunctionDeclNode node = (FunctionDeclNode) visit(ctx.functionField());
        node.setReturnType(returnType);
        return node;
    }

    @Override
    public Node visitVoidFunction_(MxParser.VoidFunction_Context ctx) {
        TypeNode returnType = new VoidTypeNode();
        FunctionDeclNode node = (FunctionDeclNode) visit(ctx.functionField());
        node.setReturnType(returnType);
        return node;
    }

    @Override
    public Node visitFunctionField(MxParser.FunctionFieldContext ctx) {
        String name = ctx.Identifier().getText();
        List<VariableDeclNode> params = new ArrayList<>();
        for (MxParser.ParamExprContext param : ctx.paramExprField().paramExpr()) {
            params.add((VariableDeclNode) visit(param));
        }
        BlockNode body = (BlockNode) visit(ctx.functionBody());
        return new FunctionDeclNode(null, name, params, body,
                null, new Location(ctx.Identifier()), new Location(ctx.paramExprField()),
                new Location(ctx.functionBody()));
    }

    @Override
    public Node visitParamExpr(MxParser.ParamExprContext ctx) {
        TypeNode type = (TypeNode) visit(ctx.type());
        String name = ctx.Identifier().getText();
        return new VariableDeclNode(type, name, null,
                new Location(ctx.type()), new Location(ctx.Identifier()), null);
    }

    @Override
    public Node visitFunctionBody(MxParser.FunctionBodyContext ctx) {
        return visit(ctx.block());
    }


    // Block
    @Override
    public Node visitBlock(MxParser.BlockContext ctx) {
        List<Node> statements = new ArrayList<>();
        for (MxParser.StatementContext state : ctx.statement()) {
            statements.add(visit(state));
        }
        return new BlockNode(statements);
    }


    // Type
    @Override
    public Node visitType(MxParser.TypeContext ctx) {
        String type = ctx.nonArrayType().getText();
        if (ctx.LBRACK().size() != 0) {
            return new ArrayTypeNode(type, ctx.LBRACK().size());
        } else {
            return new NonArrayTypeNode(ctx.getText());
        }
    }


    // Expression
    @Override
    public Node visitLiteral(MxParser.LiteralContext ctx) {
        String val = ctx.getText();
        LiteralExprNode node;
        switch (ctx.literalType.getType()) {
            case MxParser.BoolLiteral:
                node = new BoolLiteralNode(val);
                break;
            case MxParser.IntLiteral:
                node = new IntLiteralNode(val);
                break;
            case MxParser.StringLiteral:
                node = new StringLiteralNode(val);
                break;
            case MxParser.NULL:
                node = new NullLiteralNode();
                break;
            default:
                throw new RuntimeException("Get unexpected literal type when visiting literal");
        }
        return node;
    }

    @Override
    public Node visitIdentifier_(MxParser.Identifier_Context ctx) {
        return new IdentifierExprNode(ctx.getText(), new Location(ctx));
    }


    // Binary Expression
    @Override
    public Node visitAssignExpr_(MxParser.AssignExpr_Context ctx) {
        return new BinaryExprNode((ExprNode) this.visit(ctx.expr(0)),
                ExprNode.OPs.Assign, (ExprNode) this.visit(ctx.expr(1)));
    }

    // Unary Expression
    @Override
    public Node visitNewCreator_(MxParser.NewCreator_Context ctx) {
        return visit(ctx.creator());
    }

    @Override
    public Node visitCreator(MxParser.CreatorContext ctx) {
        String createType = ctx.createdName().getText();
        Integer dim = 0;
        List<ExprNode> dimArgs = new ArrayList<>();
        if (ctx.arrayCreatorRest() != null) {
            dim = ctx.arrayCreatorRest().LBRACK().size();
            for (MxParser.ExprContext exprs : ctx.arrayCreatorRest().expr()) {
                dimArgs.add((ExprNode) visit(exprs));
            }
        }
        return new NewExprNode(createType, dim, dimArgs);
    }

    //TODO
}
